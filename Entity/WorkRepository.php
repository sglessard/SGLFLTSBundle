<?php

/*
 * This file is part of the SGLFLTSBundle package.
 *
 * (c) Simon Guillem-Lessard <s.g.lessard@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace SGL\FLTSBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * WorkRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class WorkRepository extends EntityRepository
{
    /*
     * Retrieve Works (custom find)
     *
     * @param bool $queryBuilder (return query builder only)
     * @return Doctrine Collection or Query Builder
     */
    public function retrieve($queryBuilder = false)
    {
        $query = $this->createQueryBuilder('w')
            ->select('w')
            ->orderBy('w.worked_at', 'DESC')
            ->addOrderBy('w.started_at', 'DESC')
        ;

        return $this->dispatch($query, $queryBuilder);
    }

    /*
     * Retrieve Works by Part
     *
     * @param integer $id_part
     * @param bool $queryBuilder (return query builder only)
     * @return Doctrine Collection or Query Builder
     */
    public function retrieveByPart($id_part,$queryBuilder = false)
    {
        $query = $this->retrieve(true);

        $query->innerJoin('w.task', 'wt')
             ->innerJoin('wt.part', 'wtp')
             ->where('wtp.id = :id_part')
             ->setParameters(array(
                 'id_part' =>$id_part,
             ))
        ;

        return $this->dispatch($query, $queryBuilder);
    }

    /*
     * Retrieve Works by date
     *
     * @param \DateTime $date
     * @param bool $queryBuilder (return query builder only)
     * @return Doctrine Collection or Query Builder
     */
    public function retrieveByDate(\DateTime $date,$queryBuilder = false)
    {
        $query = $this->retrieve(true);

        $query->where('w.worked_at = :date')
            ->orderBy('w.worked_at', 'ASC')
            ->addOrderBy('w.started_at', 'ASC')
             ->setParameters(array(
                 'date' =>$date->format('Y-m-d'),
             ))
        ;

        return $this->dispatch($query, $queryBuilder);
    }

    public function retrieveLatest($queryBuilder = false)
    {
        $query = $this->retrieve(true);

        $query->innerJoin('w.task', 'wt')
             ->innerJoin('wt.part', 'wtp')
             ->innerJoin('wtp.project', 'wtpp')
             ->setMaxResults(1)
        ;

        return $this->dispatch($query, $queryBuilder, true);
    }

    /*
     * retrieveDummyPartWork
     *
     * @param Part $part
     *
     * @return Work
     */
    public function retrieveDummyPartWork(Part $part) {
        $work = new Work();
        $work->setStartedAt(new \Datetime());
        $work->setEndedAt(new \Datetime());
        
        return $work;
    }

    /**
     * retrieveUnbilledByPart : retrieve all part's unbilled works
     *
     * @param $id_part
     * @param bool $queryBuilder
     * @return mixed
     */
    public function retrieveUnbilledByPart($id_part,$queryBuilder = false)
    {
        $query = $this->retrieve(true);

        $query->innerJoin('w.task', 'wt')
             ->innerJoin('wt.part', 'wtp')
             ->where('wtp.id = :id_part')
             ->andWhere('w.bill is null')
             ->setParameters(array(
                 'id_part' =>$id_part,
             ))
        ;

        return $this->dispatch($query, $queryBuilder);
    }

    /**
     * @param string $from
     * @param string $to
     *
     * @return mixed
     */
    public function findByDate($from, $to)
    {
        $query = $this->retrieve(true);
        
        $query->where('w.worked_at >= :from')
            ->andWhere('w.worked_at <= :to')
            ->setParameters(array(
                'from' =>$from,
                'to' =>$to,
             ));
        
        return $this->dispatch($query, false);
    }

    /*
     * dispatch
     *
     * @param Query Builder $query
     * @param boolean  $queryBuilder (return query builder only)
     * @param boolean  $single
     *
     * @return Doctrine Collection or Query Builder
     */
    private function dispatch($query, $queryBuilder,$single=false) {
        if ($queryBuilder) {
            return $query;
        } else {

            $results = $query->getQuery()->getResult();

            if ($single && isset($results[0])) {
                return $results[0];
            } else {
                return $results;
            }
        }
    }
}
